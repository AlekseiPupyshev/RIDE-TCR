{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let noMark = "no"
let genesis = "3Ms9dv5wrt3kPXeT2g9yLM2LhS33CT7iuiQ"

# (GLOBALS) TCR implementation with commit-reveal scheme
let maxVoters = 3
let majorityCnt = 2
let newItemFee = 500000000/1000
let voteItemFee = 150000000/1000

@Callable(i)
func inviteUser(account: String) = {
    let currKey = toBase58String(i.caller.bytes)
    let refKey = "wl_ref_" + account
    let ref = match getString(this, refKey) {
        case a:String => a
        case _ => noMark
    }
    let stsCurr = match getString(this, "wl_sts_" + currKey) {
        case a:String => a
        case _ => noMark
    }
    if (ref != noMark)
        then throw("User has already been invited")
    else if (stsCurr != "whitelisted" && currKey != genesis)
        then throw("Your account should be whitelisted")
    else {
        WriteSet([
            DataEntry(refKey, currKey)
        ])
    }
}

@Callable(i)
func signUp(datajson: String) = {
    let currKey = toBase58String(i.caller.bytes)
    let stsKey = "wl_sts_" + currKey
    let refKey = "wl_ref_" + currKey
    let sts = match getString(this, stsKey) {
        case a:String => a
        case _ => noMark
    }
    let refInv = match getString(this, refKey) {
        case a:String => a
        case _ => noMark
    }
    if (sts != noMark)
        then throw("User has already been whitelisted")
    else if (refInv == noMark)
        then throw("Referral invite needed")
    else {
        WriteSet([
            DataEntry("wl_bio_" + currKey, datajson),
            DataEntry("wl_blk_" + currKey, height),
            DataEntry(stsKey, "whitelisted")
        ])
    }
}

# Multi-wallet case functions:
@Callable(i)
func deposit() = {
   let pmt = extract(i.payment)
   if (isDefined(pmt.assetId)) then throw("can hodl waves only at the moment")
   else {
        let currentKey = toBase58String(i.caller.bytes)
        let currentAmount = match getInteger(this, currentKey) {
            case a:Int => a
            case _ => 0
        }
        let newAmount = currentAmount + pmt.amount
        WriteSet([
            DataEntry(currentKey, newAmount)
        ])
   }
}
@Callable(i)
func withdraw(amount: Int) = {
        let currentKey = toBase58String(i.caller.bytes)
        let currentAmount = match getInteger(this, currentKey) {
            case a:Int => a
            case _ => 0
        }
        let newAmount = currentAmount - amount
     if (amount < 0)
            then throw("Can't withdraw negative amount")
    else if (newAmount < 0)
            then throw("Not enough balance")
            else ScriptResult(
                    WriteSet([DataEntry(currentKey, newAmount)]),
                    TransferSet([ScriptTransfer(i.caller, amount, unit)])
                )
    }
# Token Curated Registries
@Callable(i)
func addItem(itemId: String, expirationABlock: Int, expirationOne: Int, expirationTwo: Int, datajson: String) = {
    let currentAcc = toBase58String(i.caller.bytes)
    let wlStsCurr = match getString(this, "wl_sts_" + currentAcc) {
        case a:String => a
        case _ => noMark
    }
    let currentAmount = match getInteger(this, currentAcc) {
            case a:Int => a
            case _ => throw("The dApp deposit is not exist")
    }
    let item = match getString(this, currentAcc) {
            case a:String => a
            case _ => noMark
    }
    if (currentAmount < newItemFee)
        then throw("Not enough funds to add new item")
    else if (wlStsCurr != "whitelisted")
        then throw("User has not been waitlisted yet")
    else if (item != noMark)
        then throw("An item is already exist")
    else if (expirationABlock < 2 || expirationOne < 3 || expirationTwo < 4)
        then throw("Incorrect time parameters")
    else WriteSet([
        DataEntry(currentAcc, currentAmount - newItemFee),
        DataEntry("author_" + itemId, currentAcc),
        DataEntry("block_" + itemId, height),
        DataEntry("expiration_block_" + itemId, height + expirationABlock),
        DataEntry("bank_" + itemId, newItemFee),
        DataEntry("status_" + itemId, "new"),
        DataEntry("jsondata_" + itemId, datajson),
        DataEntry("expiration_one_" + itemId, height + expirationOne),
        DataEntry("expiration_two_" + itemId, height + expirationTwo)
    ])
}